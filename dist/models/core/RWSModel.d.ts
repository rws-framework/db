import { IModel } from '../interfaces/IModel';
import { IRWSModelServices } from '../interfaces/IRWSModelServices';
import { OpModelType } from '../interfaces/OpModelType';
import { FindByType, IPaginationParams } from '../../types/FindParams';
import { DBService } from '../../services/DBService';
import { ISuperTagData } from '../../decorators/RWSCollection';
declare class RWSModel<T> implements IModel {
    static services: IRWSModelServices;
    [key: string]: any;
    id: string | number;
    static _collection: string;
    static _RELATIONS: {};
    static _NO_ID: boolean;
    static _SUPER_TAGS: ISuperTagData[];
    static _BANNED_KEYS: string[];
    static allModels: OpModelType<any>[];
    static _CUT_KEYS: string[];
    private postLoadExecuted;
    constructor(data?: any);
    isPostLoadExecuted(): boolean;
    setPostLoadExecuted(): void;
    checkForInclusionWithThrow(): void;
    static checkForInclusionWithThrow(this: OpModelType<any>, checkModelType: string): void;
    checkForInclusion(): boolean;
    static checkForInclusion(this: OpModelType<any>, checkModelType: string): boolean;
    protected _fill(data: any): RWSModel<T>;
    protected hasRelation(key: string): Promise<boolean>;
    protected bindRelation(key: string, relatedModel: RWSModel<any>): {
        connect: {
            id: string | number;
        };
    };
    _asyncFill(data: any, fullDataMode?: boolean, allowRelations?: boolean, postLoadExecute?: boolean): Promise<T>;
    private getModelScalarFields;
    private getRelationOneMeta;
    static getRelationOneMeta(model: any, classFields: string[]): Promise<import("..").RelOneMetaType<import("../..").IRWSModel>>;
    private getRelationManyMeta;
    static getRelationManyMeta(model: any, classFields: string[]): Promise<import("..").RelManyMetaType<import("../..").IRWSModel>>;
    static paginate<T extends RWSModel<T>>(this: OpModelType<T>, paginateParams: IPaginationParams, findParams?: FindByType): Promise<T[]>;
    toMongo(): Promise<any>;
    getCollection(): string | null;
    static getCollection(): string | null;
    save(): Promise<this>;
    static getModelAnnotations<T extends unknown>(constructor: new () => T): Promise<Record<string, {
        annotationType: string;
        metadata: any;
    }>>;
    preUpdate(): Promise<void>;
    postLoad(): Promise<void>;
    postUpdate(): Promise<void>;
    preCreate(): Promise<void>;
    postCreate(): Promise<void>;
    static isSubclass<T extends RWSModel<T>, C extends new () => T>(constructor: C, baseClass: new () => T): boolean;
    hasTimeSeries(): boolean;
    static checkTimeSeries(constructor: any): boolean;
    isDbVariable(variable: string): Promise<boolean>;
    static checkDbVariable(constructor: any, variable: string): Promise<boolean>;
    sanitizeDBData(data: any): any;
    static watchCollection<T extends RWSModel<T>>(this: OpModelType<T>, preRun: () => void): Promise<any>;
    static findOneBy<T extends RWSModel<T>>(this: OpModelType<T>, findParams?: FindByType): Promise<T | null>;
    static find<T extends RWSModel<T>>(this: OpModelType<T>, id: string | number, findParams?: Omit<FindByType, 'conditions'>): Promise<T | null>;
    static findBy<T extends RWSModel<T>>(this: OpModelType<T>, findParams?: FindByType): Promise<T[]>;
    static delete<T extends RWSModel<T>>(this: OpModelType<T>, conditions: any): Promise<void>;
    delete<T extends RWSModel<T>>(): Promise<void>;
    static create<T extends RWSModel<T>>(this: new () => T, data: any): Promise<T>;
    static loadModels(): OpModelType<any>[];
    loadModels(): OpModelType<any>[];
    private checkRelDisabled;
    static setServices(services: IRWSModelServices): void;
    getDb(): DBService;
    static count(where?: {
        [k: string]: any;
    }): Promise<number>;
    static getDb(): DBService;
    reload(): Promise<RWSModel<T> | null>;
}
export { RWSModel };
